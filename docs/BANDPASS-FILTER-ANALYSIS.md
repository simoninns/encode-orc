# ld-chroma-encoder Bandpass Filtering Analysis

## Overview
The ld-chroma-encoder (from ld-decode-tools) uses FIR (Finite Impulse Response) low-pass filters to prevent high-frequency artifacts (ringing, aliasing) when encoding RGB images to PAL and NTSC composite video. This addresses the exact issue you're experiencing with HF artifacts on vertical color bar edges.

## Key Findings

### 1. Filter Architecture
- **Filter Type**: Constexpr compile-time FIR filters
- **Location**: `tools/library/filter/firfilter.h` (template implementation)
- **Application**: Applied horizontally to each scanline after Y/U/V conversion

### 2. PAL Encoder Filtering

#### UV Filter (1.3 MHz Low-Pass)
**File**: `tools/ld-chroma-decoder/encoder/palencoder.cpp` (lines 161-171)

```cpp
// 1.3 MHz low-pass Gaussian filter
// Generated by: c = scipy.signal.gaussian(13, 1.52); c / sum(c)
//
// The UV filter should be 0 dB at 0 Hz, >= -3 dB at 1.3 MHz, <= -20 dB at
// 4.0 MHz. [Clarke p8]
static constexpr std::array<double, 13> uvFilterCoeffs {
    0.00010852890120228184, 0.0011732778293138913, 0.008227778710181127, 0.03742748297181873,
    0.11043962430879829, 0.21139051659718247, 0.2624655813630064, 0.21139051659718247,
    0.11043962430879829, 0.03742748297181873, 0.008227778710181127, 0.0011732778293138913,
    0.00010852890120228184,
};
static constexpr auto uvFilter = makeFIRFilter(uvFilterCoeffs);
```

**Application** (lines 295-297):
```cpp
// Low-pass filter U and V to 1.3 MHz [Poynton p342]
uvFilter.apply(U);
uvFilter.apply(V);
```

**Characteristics**:
- 13-tap symmetric Gaussian window filter
- Generated using SciPy: `gaussian(13, 1.52)` normalized
- Cuts chroma at 1.3 MHz to prevent aliasing
- Attenuation: ≥ -3 dB @ 1.3 MHz, ≤ -20 dB @ 4.0 MHz

### 3. NTSC Encoder Filtering

#### UV Filter (1.3 MHz Low-Pass)
**File**: `tools/ld-chroma-decoder/encoder/ntscencoder.cpp` (lines 149-153)

```cpp
// 1.3 MHz low-pass filter
// The filter should be 0 dB at 0 Hz, >= -2 dB at 1.3 MHz, < -20 dB at 3.6 MHz.
static constexpr std::array<double, 9> uvFilterCoeffs {
    0.0021, 0.0191, 0.0903, 0.2308, 0.3153,
    0.2308, 0.0903, 0.0191, 0.0021
};
static constexpr auto uvFilter = makeFIRFilter(uvFilterCoeffs);
```

**Characteristics**:
- 9-tap symmetric filter (shorter than PAL)
- Cuts chroma at 1.3 MHz
- Attenuation: ≥ -2 dB @ 1.3 MHz, < -20 dB @ 3.6 MHz

#### Q Filter (0.6 MHz Low-Pass) - Optional Narrowband Mode
**File**: `tools/ld-chroma-decoder/encoder/ntscencoder.cpp` (lines 159-163)

```cpp
// 0.6 MHz low-pass filter
// The filter should be 0 dB at 0 Hz, >= -2 dB at 0.4 MHz, >= -6 dB at 0.5 MHz,
// <= -6 dB at 0.6 MHz. [Clarke p15]
static constexpr std::array<double, 23> qFilterCoeffs {
    0.0002, 0.0027, 0.0085, 0.0171, 0.0278, 0.0398, 0.0522, 0.0639, 0.0742, 0.0821, 0.0872,
    0.0889, 0.0872, 0.0821, 0.0742, 0.0639, 0.0522, 0.0398, 0.0278, 0.0171, 0.0085, 0.0027,
    0.0002
};
static constexpr auto qFilter = makeFIRFilter(qFilterCoeffs);
```

**Application** (lines 298-303):
```cpp
// Low-pass filter chroma components to 1.3 MHz [Poynton p342]
uvFilter.apply(C1);
if (chromaMode == NARROWBAND_Q) {
    qFilter.apply(C2);
} else {
    uvFilter.apply(C2);
}
```

**Characteristics**:
- 23-tap symmetric filter
- For narrowband Q channel (I/Q mode)
- Cuts Q at 0.6 MHz for tighter control
- Attenuation: ≥ -2 dB @ 0.4 MHz, ≥ -6 dB @ 0.5 MHz, ≤ -6 dB @ 0.6 MHz

### 4. FIR Filter Implementation

**Key Details** (`tools/library/filter/firfilter.h`):

```cpp
template <typename Coeffs>
class FIRFilter {
    // Apply to container, modifying in-place
    template <typename Container>
    void apply(Container &data) const {
        Container tmp(data.size());
        apply(data, tmp);
        data = tmp;
    }
    // ... implementation handles edge cases with zero-padding
};
```

**Filter Mechanics**:
- Odd number of taps (symmetry ensures zero phase distortion)
- Zero-padding at edges (assumes samples outside range = 0)
- Divided into 3 regions for efficiency: left overlap, middle, right overlap
- Applied per-scanline to U/V vectors (each line is independent)

### 5. Important Note: Y (Luma) is NOT Filtered

**Critical finding**: The Y (luma) channel is **NOT** low-pass filtered before encoding. It remains unfiltered and is directly used in the output:

```cpp
outputVBS[x] = qBound(-lumaGate, Y[x], lumaGate) + ...
```

This is intentional:
- Luma can support full bandwidth (typically up to 5+ MHz for PAL/NTSC)
- Only chroma (U/V) is bandpass limited to 1.3 MHz (or 0.6 MHz for Q)
- This preserves luma detail while preventing chroma aliasing artifacts

## Why This Solves Your Problem

Your vertical color bar edges show HF artifacts because:
1. **Sharp vertical transitions** in RGB → YUV create high-frequency components
2. **Without filtering**, these HF chroma components exceed Nyquist limit → aliasing
3. **With 1.3 MHz filters**, high frequencies are attenuated before modulation onto subcarrier
4. **Result**: Smooth, artifact-free color transitions

## References Used

- **[Poynton]**: Charles Poynton - "Digital Video and HDTV" (referenced throughout ld-chroma-encoder)
  - p342: UV bandwidth limiting
  - p338: Chroma encoding equations
  - p529-532: PAL parameters
  
- **[Clarke]**: R.J. Clarke - "Digital Television Fundamentals" (referenced for filter specs)
  - p8: PAL UV filter specs
  - p15: NTSC filter specs

- **[EBU]**: EBU Technical Report 358 (PAL specifications)

## Implementation for encode-orc

To apply similar filtering to your encode-orc project:

1. **Extract the FIR filter template** from ld-decode-tools `firfilter.h`
2. **Define filter coefficients** for your sample rate (match your video parameters)
3. **Apply after Y/U/V conversion**, before modulation:
   - Filter the U and V components with the 1.3 MHz low-pass coefficients
   - Apply the filter in-place to each scanline
4. **Test with color bars** - artifacts should be eliminated

### Sample Integration Pattern

```cpp
// Define filter (similar to ld-chroma-encoder)
static constexpr std::array<double, 13> uvFilterCoeffs { ... };
static constexpr auto uvFilter = makeFIRFilter(uvFilterCoeffs);

// In your line encoding:
uvFilter.apply(U);  // Apply 1.3 MHz low-pass to U
uvFilter.apply(V);  // Apply 1.3 MHz low-pass to V
// Then modulate U/V onto subcarrier as normal
```

## Next Steps

1. Consider whether your sample rate matches ld-chroma-encoder assumptions
2. Generate filter coefficients appropriate for your sample rate (using scipy.signal.gaussian or similar)
3. Verify filter cutoff frequency aligns with your chroma bandwidth requirements
4. Test on color bar patterns with vertical transitions
